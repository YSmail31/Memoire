\part{Partie Theorique}
\chapter{Introduction Au systeme temps réel}
\section{Introduction}
\section{Taxonomie sur les systèmes temps réel}
\subsection*{Différents niveaux de criticité}
\paragraph
{Les systèmes temps réel dits critiques (ou dur) correspondent ont des systèmes pour lesquelles il est intolérable qu’une échéance soit manquée au risque de causer des conséquences graves, telles que des blessures ou des pertes humaines. Les centrales nucléaires ou le guidage de missiles représentent de tels systèmes à haute criticité. Dans le domaine de l’informatique embarqué, l’automobile et l’aéronautique regorgent de systèmes critiques à l’image des équipements déclencheurs d’airbags ou des logiciels de contrôle de vol de satellite. Il est crucial que les résultats soient disponibles au moment voulu et un résultat obtenu trop tard est inutilisable, à l’instar d’un système anti-missile qui recevrait la position d’un objet volant avec du retard.}

\paragraph
{Les systèmes temps réels mou sont des systèmes où on tolère les retards et ne requièrent pas un déterminisme temporel aussi fort que les systèmes temps réels dur.
Par exemple, un logiciel de diffusion de flux vidéo produit un certain nombre d’images dans un intervalle de temps régulier. Le fait de manquer une ou plusieurs échéances ne provoque pas l’arrêt du système multimédia. La qualité de la vidéo est dégradée mais le service peut continuer de fonctionner sans risque. Donc les systèmes temps réels mou  offre le  meilleur service possible (notion de best eﬀort) et les retards dans l’obtention des résultats ne sont pas dramatiques.}

\paragraph
{A la frontière entre les systèmes temps réel dur et mou, les systèmes temps réel ferme tolèrent une certaine proportion d’échéances manquées. Ils ne considèrent que les résultats obtenus à temps et sont liés à la notion de qualité de service (QoS).}

\section{Ordonnancement monoprocesseur}

\paragraph
{Un algorithme d’ordonnancement est chargé de répartir les tâches sur un ou plusieurs processeurs : il décide quelle tâche sera exécutée sur tel processeur et pour combien de temps. }

\subsection*{Definition}
\paragraph
{Nous définissons dans un premier temps les termes habituels concernant les systèmes temps réel.}

\paragraph{
\textbf{Hors-ligne en-ligne}. Un algorithme d’ordonnancement hors-ligne prend la totalité de ses décisions d’ordonnancement avant l’exécution du système. Au contraire, un ordonnancement en-ligne prend les décisions d’ordonnancement lors de l’exécution }

\paragraph{
\textbf{Priorités}. Les algorithmes d’ordonnancement temps réel peuvent être classés suivant leur utilisation des priorités pour choisir quelle tâche doit être ordonnancée. }

\paragraph{
\textbf{Préemptif / non préemptif}. Un algorithme d’ordonnancement préemptif est un algorithme d’ordonnancement qui peut arrêter l’exécution d’une tâche, i.e. la préempter, à tout moment lors de l’exécution. Au contraire, un algorithme d’ordonnancement non préemptif ne permet aucune préemption, un travail en cours d’exécution ne peut être arrêté.}

\paragraph{
\textbf{Ordonnançabilité / Faisabilité}. Un système de tâches est dit ordonnançable si un ordonnancement existe permettant de satisfaire toutes les contraintes temps réel. Un système de tâches est dit faisable s’il existe un algorithme d’ordonnancement permettant d’ordonnancer ce système de tâches sans aucune violation d’échéances.}


\paragraph{
\textbf{Optimalité}. Un algorithme d’ordonnancement est dit optimal s’il peut ordonnancer tous les ensembles de tâches ordonnançables par d’autres algorithmes d’ordonnancement existants.}

\subsection{Algorithme d’ordonnancement à priorité fixe}
\subsubsection{Rate Monotonic \cite{LL73}}
\paragraph{
Rate Monotonic est un algorithme à priorité fixe introduit par Liu et Layland dans \cite{LL73}. Cet algorithme affecte des priorités aux tâches inversement proportionnel à leur période : plus leur période est petite, plus la tâche est prioritaire. Un exemple de système de tâche ordonnancée par Rate Monotonic est donné table 1.1. La figure 1.5 est une représentation graphique de l'ordonnancement correspondant.}
\paragraph{
\textbf{Théorème 3 \cite{LL73}}. Rate Monotonic est optimal pour l'ordonnancement de systèmes de tâches synchrones, indépendantes et à échéance sur requête en présence de préemption.}
\paragraph{
\textbf{Théorème 4 \cite{LL73} (Condition Suffisante)}. Un système temps réel composé de n tâches est ordonnançable par Rate Monotonic si : }
\begin{equation}
U = \sum_{i=1}^n \frac{C_i}{T_i} \leq n ( 2^{\frac{1}{n}} - 1)
\end{equation}

\subsubsection{Deadline Monotonic }%\cite{LW82}}
\paragraph{
Deadline Monotonic est un algorithme à priorité fixe introduit par Leung et Whitehead dans %\cite{LW82}.\\
Cet algorithme est proche de celui de Rate Monotonic, à la différence que les priorités sont maintenant affectées en fonction de l'échéance relative de chaque tâche au lieu de leur période.
Cet algorithme est optimal dans le cadre des algorithmes à priorité fixe pour des systèmes de tâches synchrones à échéance contrainte lorsque la préemption est autorisée. Monotonic et Deadline Monotonic se confondent.
\\ \textbf{Condition suffisante d'ordonnançabilité} La condition suffisante d'ordonnançabilité est inspirée de la condition suffisante d'ordonnançabilité de Liu et Layland (cf. théorème 4) :}
\paragraph{
\textbf{Théorème 6}. Un système temps réel composé de n tâches est ordonnançable par Deadline
Monotonic si la condition suivante est vérifiée :}
\begin{equation}
U = \sum_{i=1}^n \frac{C_i}{D_i} \leq n ( 2^{\frac{1}{n}} - 1)
\end{equation}

\paragraph{
\textbf{Condition necessaire et suffisante d'ordonnançabilité} Joseph et al ont proposé un test d’ordonnancabilité basé sur le pire
temps de reponse $R_{i}$.  Le pire temps de réponse est le moment ou la tache $i$ de priorité $p$ terminera son exécution quand les taches les plus prioritaire sont actifs avec elle en même temps.\\
soit $\Gamma$ = $\tau_{1},\tau_{2},. . . \tau_{n}$ un ensemble de $n$
taches.  $\Gamma$ est ordonnancable sous deadline monotonic ssi:}

\begin{equation}
\forall \tau_{i} \in \Gamma / R_{i} \leq D_{i}
\end{equation}

\begin{equation}
R_{i} = \\
\left\lbrace
\begin{array}{l}
R_{i}^0=C_{i}
\\
 R_{i}^{(k+1)}=C_{i}+\underset{j=1}{\sum}  \left \lceil 
 \frac{R_{i}^{(k)}}{T_{j}} \right \rceil * C_{j}  
\end{array}\right.
\end{equation}

\section{Ordonnancement Multiprocesseur}
\section{Conclusion}
\chapter{Etat de l'art}
\section{Introduction}
\section{Les modèles de consommation d'énerie DVFS et DPM}
\section{Les états C-states du processeur}
\section{L'endormissement de processeur (Online VS Offline)}
\section{Le Modèle d'endormissement de Dsouza}
\section{Conclusion}